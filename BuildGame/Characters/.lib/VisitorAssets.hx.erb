package <%= package %>;

import incubet.builder.world.CardinalDirection;
import incubet.isorender.Renderable;
import flash.display.BitmapData;

<% 
	embed_data.each do |state, directions|
		directions.each do |direction, frames|
			frames.each do |frame|
%>
@:bitmap("<%= frame[:filename] %>") class <%= frame[:classname] %> extends BitmapData {}
<%  
			end
		end 
	end
%>

class <%= @id.capitalize %>Assets implements VisitorAssetLibrary
{

	public var id(default, null):String;
	var _states:Hash<Hash<Array<BitmapData>>>;

	public function new()
	{
		id = "<%= @id %>";
		_states = new Hash<Hash<Array<BitmapData>>>();
		<% 
			embed_data.each do |state, directions|
		%>
		_states.set("<%= state %>", new Hash<Array<BitmapData>>());
		<%
				directions.each do |direction, frames|
		%>
		_states.get("<%= state %>").set("<%= direction %>", [ <%= frames.map{ |frame| frame[:classname] }.map { |classname| "cast new #{classname}(0,0)"}.join(",") %>] );
		<%
				end
			end 
		%>
	}

	public function getRenderable(state:String,direction:CardinalDirection):Renderable
	{
		return generateRenderable(_states.get(state).get(CardinalDirectionUtil.cardinalDirectionToString(direction)));	
	}

	inline function generateRenderable(sprites:Array<BitmapData>):Renderable
	{
		var renderable:Renderable = new Renderable();
		renderable.sprite = sprites;
		for (i in 0...renderable.sprite.length)
		{
			renderable.offset_x.push(<%= @offsets[:x] %>);
			renderable.offset_y.push(<%= @offsets[:y] %>);
		}
		return renderable;
	}
}